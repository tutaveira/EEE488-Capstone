#!/usr/bin/perl
#
#Written by Seth Abraham, March 2017
#
#small changes for 333 class, March 2018, by SA
#

#
# for debugging....
#
sub dumphash
{
  my    $hr = shift;
  local $_;

  print map { "$_ => $hr->{$_} " } keys %{$hr} ;
  print "\n";
} #sub


#
# convert decimal to a bit string of specific width
# (from perl cookbook)
#
sub d2bit
{
  local $_;
  my    $wid = shift;
  my    $num = shift;
  my    $str;
  $str = unpack( "B32",  pack("N", $num ) );
  $str = substr( $str, -$wid);

  return $str;
} #d2bit


open F,"./microcode" or die "Cannot open microcode";

#
# read microcode file, processing lines
#
#
$upc = 0;
while(<F>)
{
  s/#.*//;           # strip comments
  next if /^\s*$/;   # skip blanks

  #
  # process a signal line
  # save up the signals
  # remember their width
  # preserve their order
  #
  s/SIG\s/SIG1 /;
  if (/SIG(\d)\s+(.*)/)
  {
    $wid  = $1;
    @some = split(/\s+/, $2);
    foreach (@some)
    {
      $width{$_} = $wid;
      push @order, $_;
    }
    next;
  }
  #
  # process a constant line
  # define any constants
  # put them in the constant hash
  #
  if (/CONST\s+(.*)/)
  {
    @some = split(/\s+/,$1);
    $i    = 0;
    foreach (@some)
    {
      $constant{$_} = $i++;
    }
    next;
  }
  #
  # process a ucode label
  # essentally, this is just a constant with value of current uip
  #
  $constant{$1} = $upc if /^\s*(\S+):/;
  next if /:/;

  #
  # process a opcode line
  # an opcode is partially a uip entry (i.e. like a ucode label)
  # keep a list of our opcodes
  #
  $constant{$1} = $upc if /^\s*(\S+)\s+OPCODE/;
  push @opcodes, $_ if /OPCODE/;
  next if /OPCODE/;

  #all that is left had better be ucode lines!
  next unless /\S+/;

  #
  # save the ucode lines for later
  #
  push @lines, "$upc " . $_;
  $upc++;

} # file has a line of text


#
# go through all the signal names, and define ucode width
#
foreach (@order)
{
  $uwid += $width{$_};
}


#
# a simple but ugly way to deduce the ucode address width
# (a log2 sort of thing, essentially)
#
$wid = 3;
$num = 8;
while ($num < $upc)
{
  $num += $num;
  $wid++;
}


#
# go through each ucode line
# replace all the symbolic names (constants) with their numerical values
# check that signals on line were defined
# process the multibit signals that have a name=value format
#
# finally create the ucode line, with 0s for the signals not explicitly listed
# (which implies that a signal must be active high)
# we will output all these ucode lines later when we write the ucode file
#
foreach (@lines)
{
  #
  #expand out constants 
  #
  foreach $k (keys %constant )
  {
    s/=$k/=$constant{$k}/;
  }

  @some = split (/\s+/, $_);
  $lnum = shift @some;

  %seen = ();
  #
  # look what we saw in the ucode line
  # and scream if we did not see the right thing
  # in addition, resolve the multibit fields into bit strings in the seen field
  #
  foreach (@some)
  {  
    $seen{$1}++                    if /([^=]+)/;
    $width{$1} or die "Illegal signal $_ encountered at ucode address $lnum\n";

    $seen{$1}=d2bit($width{$1},$2) if /(\S+)=(\S+)/;
    $width{$1} or die "Illegal signal $_ encountered at ucode address $lnum\n";
  }
  $bitstr = "";
  foreach (@order)
  {
    if ($seen{$_})
    {
      $bitstr .= $seen{$_};
    }
    else
    {
      $bitstr .= "0"x$width{$_};
    }

  } #foreach part of the bit string
  $urom .= "    " . $wid . "'d" . $lnum . ": sig = " . $uwid . "'b" .  $bitstr. ";\n";

}

#
# now we look at all the opcodes so we can create the instruction decoder
#
# note we saved the opcodes as ucode labels,
# so we can use the constant table to find the uip
# for the start of each opcode
#
# we shoudl have a parameter for width of the IR, but we dont
# so we hardcode the opcode width to 8 bits.  (NOPE  6 bits!)
# Someday we shoudl fix this. (Really)
#
foreach (@opcodes)
{
  /\s*(\S+)\s+OPC/;
  $instr = $1;
  #
  #expand out constants 
  #
  foreach $k (keys %constant )
  {
    s/^\s*$k\s+/$constant{$k} /;
  }
  /(\S+)\s+OPCODE\s+(\S+)/;

  $casex .=  "    6'b"  . $2 .  " :  Uip = " . $wid . "'d" . $1 . " ;   // $instr \n";

}
  $casex .=  "    default:      Uip = " . $wid . "'d" . $constant{UD_fault} . " ;   // #UD fault \n";



#
# create verilog declarations for the symbolic signal names
#
#
foreach (@order)
{
  $declare .= "  logic ";

  $w = $width{$_} - 1;
  if ($w)
  { $declare .= "[" .  $w  . ":0]$_;\n"; }
  else
  { $declare .= "     $_;\n" ; }


}

$highaddr   = $wid - 1;
$highsignal = $uwid - 1;

#
# write signal declarations, as well as the assign that converts
# raw ucode lines to symbolic names
#
open  F, ">./sig_declare.inc" or die "cannot open sig_declare for output\n";
print F "//this file is generated by perl script mkurom.\n" .
        "//Do not edit under pain of losing your edits!\n ";
print F "parameter bw=6,aw=6,uw=$highsignal+1,ua=$highaddr+1; \n";

foreach (keys %constant )
{
  next unless /^UC_/;
  print F "  parameter $_ = ", $constant{$_}, ";\n";
}


print F $declare;
#print F "  logic [ua-1:0] Uip;\n";
print F "  logic [uw-1:0] sig;\n";
print F "  assign {" . join(",", @order) . "} = sig;\n";

#
# write the ucode verilog file
#

open  F, ">./ustore.sv" or die "cannot open ustore.sv for output\n";
print F "//this file is generated by perl script mkurom.\n" .
        "//Do not edit under pain of losing your edits!\n ";
print F " \n"
      . "module US__ ( \n      input logic ["
      . "$highaddr:0] Uip,\n      output logic ["
      . "$highsignal:0] sig \n\n"
      . "          );\n"
      . "always_comb begin\n  unique case ( Uip ) \n"
      . $urom
      . "    default: sig = " . $uwid . "'d0;\n"
      .  "  endcase\nend\n"
      . "endmodule // US__ \n"
      ;

#
# write the instruction decoder verilog file
#

open  F, ">./id.sv" or die "cannot open id.sv for output\n";
print F "//this file is generated by perl script mkurom.\n" .
        "//Do not edit under pain of losing your edits!\n ";
print F "\n"
      . "module ID__ \n"
      . " #(ua=4)\n"
      ."( \n      input logic [5:0] IR,\n"
      . "      output logic ["
      . "ua-1:0] Uip \n"
      . "            ); \n"
      . "always_comb begin\n  unique casex (IR) \n"
      . $casex
      . "  endcase\nend\n"
      . "endmodule  // ID__ \n"
      ;

